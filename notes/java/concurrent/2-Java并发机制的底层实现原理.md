# 二、Java并发机制的底层实现原理

​																										--- 《Java 并发编程的艺术》

## 1. Volatile 的应用

### volatile的定义与实现原理

`lock addl` lock 前缀指令 将当前处理器缓存行的数据写回到系统内存。这个写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。

## 2. synchronized 的实现原理与应用

+ 对于**普通同步方法**，锁是**当前实例对象**。

+ 对于**静态同步方法**，锁是**当前类的 Class 对象**。

+ 对于同步**方法块**，锁是 Synchonized 括号里配置的对象。

当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。

### Java 对象头

synchronized 用的锁是存在 Java 对象头里的。如果对象是数组类型，则虚拟机用 3 个字宽 （Word）存储对象头，如果对象是非数组类型，则用 2 字宽存储对象头。32 位虚拟机，1 字宽为 4 字节（32 位）。

**Java对象头的长度**

| 长度     | 内容                   | 说明                           |
| -------- | ---------------------- | ------------------------------ |
| 32/64bit | Mark Word              | 存储对象的 hashCode 或锁信息等 |
| 32/64bit | Class Metadata Address | 存储到对象类型数据的指针       |
| 32/64bit | Array length           | 数组的长度（如果是数组）       |
Mark Word 里默认存储对象的 HashCode、分代年龄和锁标记位。

**Mark Word 存储结构**


| 锁状态   | 29 bit 或 61 bit                                             | 1 bit 是否是偏向锁？       | 2 bit 锁标志位 |
| -------- | ------------------------------------------------------------ | -------------------------- | -------------- |
| 无锁     |                                                              | 0                          | 01             |
| 偏向锁   | 线程ID                                                       | 1                          | 01             |
| 轻量级锁 | 指向栈中锁记录的指针                                         | 此时这一位不用于标识偏向锁 | 00             |
| 重量级锁 | 指向互斥量（重量级锁）的指针<br />（指向堆中的 monitor 对象的指针） | 此时这一位不用于标识偏向锁 | 10             |
| GC 标记  |                                                              | 此时这一位不用于标识偏向锁 | 11             |

### 锁的升级与对比

锁可以升级但不能降级（`待商榷，HotSpot JVM 是支持锁降级，发
生在 Stop The World 期间，当 JVM 进入安全点的时候，会检查是否有闲置的锁，然后进行降级`）

#### 偏向锁

当一个线程访问同步块并获取锁时，会在`对象头`和`栈帧`中的锁记录里存储锁偏向的`线程 ID`，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需检查对象头的 Mark Word 里是否存储着当前线程 ID

**偏向锁的撤销**

偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识。

+ 在全局安全点（在这个时间点上没有正在执行的字节码）暂停拥有偏向锁的线程

+ 持有偏向锁的线程不处于活动状态，则将对象头设置成无锁状态
+ 持有偏向锁的线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word 要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁。
+ 唤醒暂停的线程

#### 轻量级锁

**加锁**

JVM 在当前线程的栈桢中创建用于存储锁记录的空间 Displaced Mark Word，并将对象头中的 Mark Word 复制到锁记录中。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

**解锁**

使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

#### 各种锁的对比

| 锁       | 优点                                                         | 缺点                                             | 适用场景                             |
| -------- | ------------------------------------------------------------ | ------------------------------------------------ | ------------------------------------ |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 | 适用于只有一个线程访问同步块场景。   |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度。                   | 如果始终得不到锁竞争的线程使用自旋会消耗CPU。    | 追求响应时间。同步块执行速度非常快。 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU。                            | 线程阻塞，响应时间缓慢。                         | 追求吞吐量。同步块执行速度较长。     |

## 3. 原子操作的实现原理

不可被中断的一个或一系列操作

### 处理器实现原子操作

+ 通过总线锁保证原子性：使用处理器提供的一个 `LOCK＃`信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该 处理器可以独占共享内存。
+ 通过缓存锁定来保证原子性：内存区域如果被缓存在处理器的缓存行中，并且在 Lock 操作期间被锁定，那么当它执行锁操作回写到内存时，直接修改内部的内存地址，并允许它的**缓存一致性机制**来保证操作的原子 性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。

### Java 实现原子操作

锁和循环 CAS

#### CAS 实现原子操作的问题

+ ABA 问题：使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1 `AtomicStampedReference`

+ 循环时间长开销大：让 JVM 支持处理器提供的 pause 指令

+ 只能保证一个共享变量的原子操作：`AtomicReference` 类保证对象之间的原子性，可以将多个变量放到一个对象里面进行 CAS 操作

  

