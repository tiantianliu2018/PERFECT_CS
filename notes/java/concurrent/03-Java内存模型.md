# 三、Java内存模型

​																										--- 《Java 并发编程的艺术》

## 1.Java内存模型的基础

线程之间进行通信的方式：

+ 共享内存，隐式通信
+ 消息传递，显式通信

### Java内存模型的抽象结构

Java 线程之间的通信由 **Java内存模型**（本文简称为JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。

从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。

`本地内存是JMM的 一个抽象概念，并不真实存在。`

### 指令序列的重排序

执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序

+ 编译器优化的重排序
+ 指令级并行的重排序
+ 内存系统的重排序

### 内存屏障

为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入**内存屏障**指令来禁止特定类型的处理器重排序

| 屏障类型   | 指令示例                   | 说明                                                         |
| ---------- | -------------------------- | ------------------------------------------------------------ |
| LoadLoad   | Load1; LoadLoad; Load2     | 确保 Load1 数据的装载先于 Load2 及所有后续装载指令的装载     |
| StoreStore | Store1; StoreStore; Store2 | 确保 Store1 数据对其他处理器可见（刷新到内存）先于 Store2 及所有后续存储指令的存储 |
| LoadStore  | Load1; LoadStore; Store2   | 在 Store2 及后续写入操作被刷新到内存前，保证 Load1 要读取的数据被读取完毕。 |
| StoreLoad  | Store1; StoreLoad; Load2   | 在 Load2 及后续所有读取操作执行 前，保证 Store1 的写入对所有处理器可⻅。 |

StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他 3 个屏障的效果。

执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。

### happens-before

happens-before 规则

+ 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。

+ 监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。

+ volatile变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。

+ 传递性：如果 A happens-before B，且B happens-before C，那么 A happens-before C。

>两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前

---

## 2. 重排序

### 数据依赖性

如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间 就存在数据依赖性。

编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。

### as-if-serial语义

不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变

### 重排序对多线程的影响

在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。

---

## 3. 　顺序一致性

顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参照。

### 数据竞争与顺序一致性

JMM 对正确同步的多线程程序的内存一致性做了如下保证：

如果程序是正确同步的，程序的执行将具有`顺序一致性`即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。

### 顺序一致性内存模型

+ 一个线程中的所有操作必须按照程序的顺序来执行。 

+ （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内 存模型中，每个操作都必须原子执行且立刻对所有线程可见。

---

## 4. volatile的内存语义

### Volatile 特性

+ 可见性。变量的内存可⻅性。

+ 原子性：对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。

### Volatile 内存语义

当`写`一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。

当`读`一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。

为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。

+ 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。 
+ 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。 
+ 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。 
+ 在每个 volatile 读操作的后面再插入一个 LoadStore 屏障。

---

## 5. 锁的内存语义

当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中

当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。

## 6. final 域的内存语义

## 7. happens-before

只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序）， 编译器和处理器怎么优化都行。

### 　happens-before 的定义

1）如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。

2）两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么这种重排序并不非法。

### happens-before 规则

+ 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。 
+ 监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。 
+ volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个volatile域的读。
+ 传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。
+ `start()` 规则：如果线程 A 执行操作 `ThreadB.start()`（启动线程B），那么 A 线程的 `ThreadB.start()` 操作 happens-before 于线程 B 中的任意操作。
+ `join()` 规则：如果线程 A 执行操作 `ThreadB.join()` 并成功返回，那么线程 B 中的任意操作 happens-before于线程 A 从`ThreadB.join()`操作成功返回。

## 8. 双重检查锁定与延迟初始化

单例模式中双重检查，由于指令重排序导致的错误。

将变量用 volatile 修饰

### 基于类初始化



## 9. Java内存模型综述

