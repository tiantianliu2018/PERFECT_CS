# 五 Java 中的锁

---

## 1. Lock 接口

在使用时需要显式地获取和释放锁：

```java
Lock lock = new ReentrantLock(); 
lock.lock();
try {

} finally {
		lock.unlock(); 
}
```

在 `finally` 块中释放锁，目的是保证在获取到锁之后，最终能够被释放。

## 2. 队列同步器

队列同步器 `AbstractQueuedSynchronizer` ，是用来构建锁或者其他同步组件的基础框架，它使用了一个 int 成员变量表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的排队工作。

同步器的主要使用方式是**继承**，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件 ( `ReentrantLock`、 `ReentrantReadWriteLock`和`CountDownLatch`等)。

同步器的设计是基于**模板方法模式**的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些 模板方法将会调用使用者重写的方法。

重写同步器指定的方法时，需要使用同步器提供的如下 3 个方法来访问或修改同步状态：

+ `getState()`：获取当前同步状态。
+ `setState(int newState)`：设置当前同步状态。
+ `compareAndSetState(int expect,int update)`：使用CAS设置当前状态，该方法能够保证状态设置的原子性。

同步器可重写的方法：

+ `isHeldExclusively()` 该线程是否正在独占资源。只有用到 condition 才需要去实现它。 
+ `tryAcquire(int)` ：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。 
+ `tryRelease(int)` 独占方式。尝试释放资源，成功则返回 true，失败则返回 false。
+  `tryAcquireShared(int)` ：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余

可用资源；正数表示成功，且有剩余资源。

+ `tryReleaseShared(int)` ：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回

true，否则返回 false。

## 3. 重入锁

重入锁 `ReentrantLock`，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。

#### 3.2 实现重进入

重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题：

+ 线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。
+ 锁的最终释放。线程重复 n 次获取了锁，随后在第 n 次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于 0 时表示锁已经成功释放。

#### 3.2 公平与非公平获取锁的区别

公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是 FIFO。

**公平性锁**保证了锁的获取按照 FIFO 原则，而代价是进行**大量的线程切换**。

**非公平性锁**虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。

## 4. 读写锁

读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。

Java 并发包提供读写锁的实现是 `ReentrantReadWriteLock`

## 5. LockSupport 工具

LockSupport 定义了一组以 `park` 开头的方法用来阻塞当前线程，以及 `unpark(Thread thread)` 方法来唤醒一个被阻塞的线程。

## 6. Condition 接口

调用 Condition 的 `await()` 方法(或者以await开头的方法)，会使当前线程进入等待队列并**释放锁**，同时线程状态变为等待状态。当从 `await()` 方法返回时，当前线程一定获取了 Condition 相关联的锁。