# 四 Java 并发编程基础

​																										--- 《Java 并发编程的艺术》

---

## 1. 线程简介

**线程**：操作系统调度的基本单元，也叫轻量级进程。一个进程可以创建多个线程。

### 线程优先级

线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。

在 Java 线程中，通过一个整型成员变量 priority 来控制优先级，优先级的范围从 1~10，在线 程构建的时候可以通过 `setPriority(int)` 方法来修改优先级，默认优先级是 5，优先级高的线程分配时间片的数量要多于优先级低的线程。

### 线程的状态

| 状态         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NEW          | 初始状态，线程被创建、但是还没有调用 `start()` 方法          |
| RUNNABLE     | 运行状态，Java 线程将操作系统中的**就绪**和**运行**两种状态笼统地称作“运行中” |
| BLOCKED      | 阻塞状态，表示线程阻塞于锁                                   |
| WAITING      | 等待状态，线程进入等待状态，表示当前线程需要等待其他线程作出一些特定的动作（通知或中断） |
| TIME_WAITING | 超时等待，该状态不同于 WAITING，它是可以在指定的时间自行返回的 |
| TERMINATED   | 终止状态，表示当前线程已经执行完毕                           |

状态转换

![image-20200523205009926](/Users/ttl/career/CS_LEARN/notes/java/concurrent/thread.png)

### Daemon 线程

## 2. 启动和终止线程

一个新构造的线程对象是由其 **parent 线程**来进行空间分配的。

线程对象在初始化完成之后，调用 `start()` 方法就可以启动这个线程 。

中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。其他线程通过调用该线程的 `interrupt()` 方法对其进行中断操作。

线程的暂停、恢复和停止使用 `suspend(), resume(), stop()` , 但是这些 API 是过期的，也就是不建议使用的.

 `suspend()` 方法，在调用后，线程不会释放已经占有的资源(比如锁)，而是占有着资源进入睡眠状态，这样容易引发死锁问题。

`stop()` 方法在终结 一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。

## 3. 线程间通信

### 3.1 volatile 和 synchronized 关键字

关键字 `volatile` 可以用来修饰字段(成员变量)，告知程序任何对该变量的访问均需要从**共享内存**中获取，而对它的改变必须**同步刷新回共享内存**，它能保证所有线程对变量访问的`可见性`。

关键字 `synchronized` 可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的`可见性`和`排他性`。

### 3.2 等待/通知机制

| 方法名称        | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| notify()        | 通知一个在对象上等待的线程，使其从 wait 方法返回，而返回的前提是该线程获取到了该对象的锁。 |
| notifyAll()     | 通知所有等待在该对象上的线程。                               |
| wait()          | 调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或中断才会返回，调用 wait 方法后，会释放对象的锁。 |
| wait(long)      | 超时等待一段时间，等待 n 毫秒，没有通知就返回。              |
| wait(long, int) | 超时时间，纳秒                                               |

### 3.3 等待/通知的经典范式

**等待方遵循如下原则：**

1) 获取对象的锁。 

2) 如果条件不满足，那么调用对象的 `wait()` 方法，被通知后仍要检查条件。 

3) 条件满足则执行对应的逻辑。

```java
synchronized(对象) { 
  	while(条件不满足) {
    	对象.wait(); 
  	} 
  	对应的处理逻辑
}
```

**通知方遵循如下原则：**

1) 获得对象的锁。 

2) 改变条件。 

3)通知所有等待在对象上的线程。

```java
synchronized(对象) { 
		改变条件
		对象.notifyAll();
}
```

### 3.4 管道输入/输出流

管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于**线程之间的数据传输**，而传输的媒介为**内存**。

### 3.5 Thread.join() 的使用

如果一个线程 A 执行了 `thread.join()` 语句，其含义是：当前线程 A 等待 thread 线程终止之后才从 `thread.join()` 返回

### 3.6 ThreadLocal的使用



## 4. 线程应用实例

